import sys

input = sys.stdin.readline


# 1309 동물원
# 가로 2칸, 세로 n칸의 우리에 사자가 들어간 칸이 서로 인접하지 않도록
# 사자를 배치하는 경우의 수를 구하는 문제.

# 첫 번째 풀이
def sol1309():
    # 우리의 세로길이
    n = int(input())

    # 나머지연산을 위한 소수
    mod = 9901

    # 현재 행에 사자를 배치하지 않은경우, 첫 번째 칸에 배치한 경우, 두 번째 칸에 배치한 경우의 수를 각각 나타낸다
    dp = [1, 1, 1]

    # 사자를 배치하지 않는다면 이전 행의 상태와 상관이 없기 떄문에 이전 행의 모든 경우의수를 합한다
    # 사자를 첫 번째 칸에 배치한다면 이전 행에 사자를 첫 번째 칸에 배치한 경우를 제외
    # 사자를 두 번째 칸에 배치한다면 이전 행에 사자를 두 번째 칸에 배치한 경우를 제외
    for _ in range(1, n):
        dp = [sum(dp) % mod, (dp[0] + dp[2]) % mod, (dp[0] + dp[1]) % mod]

    # 세 가지 경우의 수를 모두 더하여 나머지연산 후 반환
    return sum(dp) % 9901


# 두 번째 풀이
# 첫 번쨰 풀이의 최적화
def sol1309_2():
    # 우리의 세로길이
    n = int(input())

    # 현재 행에서 사자를 배치하지 않은 경우의 수 zero 와 사자를 배치하는 모든 경우의 수 answer
    zero, answer = 1, 3

    # 첫 번째 풀이에서 사자를 배치하지 않은경우, 첫 번째에 배치한 경우, 두 번째에 배치한 경우를 각각 a, b, c 라 할 때
    # 행이 넘어갈 때 마다 a, b, c = (a + b + c, a + c, a + b) 가 성립한다.
    # 즉, 현재 행의 경우의 수가 각각 a, b, c 일때, 다음 행의 경우의 수의 합은
    # 3 * a + 2 * b + 2 * c = a + 2 * (a + b + c) 가 된다.
    # 여기서 a 는 zero,  a+b+c 는 answer 이기 때문에
    # zero(i), answer(i) = answer(i-1), zero(i-1) + 2 * answer(i-1) 라는 점화식이 성립한다
    for _ in range(1, n):
        zero, answer = answer, (answer * 2 + zero) % 9901

    # 사자를 우리에 배치하는 경우의 수를 반환
    return answer
