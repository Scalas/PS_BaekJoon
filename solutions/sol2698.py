import sys

input = sys.stdin.readline


# 2698 인접한 비트의 갯수
# n자리 수열 b 에 대해 b[i] * b[i+1] 이 1이라면 i와 i+1 번째 비트는 인접한 비트가 된다.
# 인접한 비트가 k개인 n자리 수열의 갯수를 구하는 문제
def sol2698():
    answer = []
    for _ in range(int(input())):
        n, k = map(int, input().split())

        # dp[i][j][0] 는 길이가 i이고 인접 비트수가 j개인 수열중 0으로 끝나는 수열
        # dp[i][j][1] 는 길이가 i이고 인접 비트수가 j개인 수열중 1로 끝나는 수열
        dp = [[[0, 0] for _ in range(k+1)] for _ in range(n+1)]

        # 길이가 1인 수열은 인접 비트수가 최대 0이며 0으로 끝나는것 하나(0) 1로 끝나는것 하나(1)
        dp[1][0] = [1, 1]

        # 길이가 2 이상인 수열
        for i in range(2, n+1):
            # 길이가 i이고 인접비트수가 0인 수열중
            # 0으로 끝나는 수열의 수는 길이가 i-1이고 인접비트수가 0인 수열의 총 갯수
            # 1로 끝나는 수열의 수는 길이가 i-1이고 인접비트수가 0인 수열중 0으로 끝나는 수열의 갯수(뒤에 1을 붙여도 인접 비트수가 늘어나지 않음)
            dp[i][0] = [sum(dp[i-1][0]), dp[i-1][0][0]]
            for j in range(1, k+1):
                # 길이가 i-1이고 인접비트수가 j인 수열 뒤에 0을 추가
                dp[i][j][0] = sum(dp[i-1][j])

                # 길이가 i-1이고 인접비트수가 j인 수열중 끝자리가 0인 것에 1을 추가
                # 길이가 i-1이고 인접비트수가 j-1인 수열중 끝자리가 1인것에 1을 추가
                dp[i][j][1] = dp[i-1][j-1][1] + dp[i-1][j][0]

        # 길이가 n이고 인접비트수가 k인 수열의 갯수 반환
        answer.append(sum(dp[n][k]))
    return '\n'.join(map(str, answer))
