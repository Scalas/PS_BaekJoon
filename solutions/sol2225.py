import sys

input = sys.stdin.readline


# 2225 합분해
# 0 부터 N 까지의 정수를 k 번 더해서 합이 N이 되는 경우의 수를 구하는 문제

# 나의 풀이
def sol2225():
    n, k = map(int, input().split())

    # 0 부터 N 까지의 정수를 한 번만 더 했을 때는 합이 i 가 되는 경우(cnt[i]) 가
    # 자기 자신을 더한 경우 하나 뿐이기 때문에 1이 된다
    cnt = [1] * (n+1)

    # 숫자를 더하는 과정을 k-1 번 반복
    for _ in range(k-1):
        tcnt = [0] * (n+1)
        # 이전 단계에서 만들어진 숫자들에 0 부터 N 까지의 정수를 더해 만들 수 있는 수를 헤아린다
        for i in range(n+1):
            for j in range(n+1):
                val = i + j
                if val <= n:
                    tcnt[val] += cnt[i]
                else:
                    break
        # 이번 단계에서 만들어진 숫자들의 갯수로 cnt 를 대체
        cnt = tcnt

    # cnt[n] = cnt[-1] 이 정답이 된다.
    return cnt[-1] % 1000000000


# 좀더 빠른 풀이
# 이 풀이의 경우 첫 번째 풀이와 얻는 배열의 값은 결국 같지만
# 일일히 수를 더하지 않고 경우의 수를 따져 바로 cnt[i] 를 구한다
# 이러한 점화식을 찾아내는 것이 익숙하지 않다면 보다 간단한 방법으로 몇개의 값을 구한 뒤
# 나온 값들에서 점화식을 유추하는 방법을 고려해보는 것도 좋을 듯 하다.
def sol2225_2():
    n, k = map(int, input().split())

    # 0 부터 N 까지의 정수를 한 번만 더 했을 때는 합이 i 가 되는 경우(cnt[i]) 가
    # 자기 자신을 더한 경우 하나 뿐이기 때문에 1이 된다
    cnt = [1] * (n + 1)

    # 숫자를 더하는 과정을 k-1 번 반복
    for _ in range(k - 1):
        # 같은 횟수만큼 더하여 n-1이 되는 경우의 어느 한 값에 1을 더하거나
        # 이전 단계에서 이미 합이 n이 된 경우에 0을 하나 추가하는 것으로
        # 현 단계에서 n을 만들 수 있다.

        # 같은 횟수로 n-1을 만든 경우의 수는 미리 구해둔 cnt[i-1] 이 되며
        # 이전 단계는 아직 현 단계의 계산을 적용하지 않은 cnt[i] 가 되기 때문에
        # 결과적으로 cnt[i] = cnt[i-1] + cnt[i] 로 누적합을 구하는 것이 된다.
        for i in range(1, n + 1):
            cnt[i] += cnt[i-1]

    # cnt[n] = cnt[-1] 이 정답이 된다.
    return cnt[-1] % 1000000000
