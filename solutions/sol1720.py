import sys

input = sys.stdin.readline


# 1720 타일 코드
# 2 * n 크기의 바닥을 1 * 2(혹은 2 * 1) 타일과 2 * 2 타일로 채우는 경우의 수를 구하는 문제
# 단, 좌우 반전시 겹치는 패턴은 한가지 경우의 수로 따진다.
def sol1720():
    n = int(input())
    # 좌우 반전을 고려하지 않고 겹치지 않는 모든 경우의 수를 구한다
    dp = [1, 1, 3]
    for i in range(3, n+1):
        dp.append(dp[-1] + dp[-2] * 2)

    # 모든 경우의 수는 반전시 겹치는 경우의 수를 1개씩 가지기 때문에 반으로 나눠주는 것으로 제거할 수 있다.
    # 단, 좌우 대칭인 패턴은 반전되는 경우의 수가 자기 자신과 같은 패턴이기 때문에 이미 제거된 상태
    # 위에서 구한 모든 경우의 수에 좌우가 반전인 경우의 수만큼을 다시 더해준 뒤 반으로 나누면
    # 좌우 반전시 겹치는 경우의 수를 제거할 수 있다.
    # 1. n이 짝수일 때 좌우대칭이 되는 경우의 수
    #   2 * (n//2) 의 패턴을 뒤집어서 이어붙이는 경우 => dp[n//2]
    #   2 * (n//2-1) 의 패턴을 2 * 2의 패턴의 좌우에 붙이는 경우 => dp[n//2-1] * 2
    # 2. n이 홀수일 때 좌우대칭이 되는 경우의 수
    #   2 * (n//2) 의 패턴을 2 * 1 의 패턴의 좌우에 붙이는 경우 => dp[n//2] * 1
    return (dp[n] + dp[n//2] + (0 if n % 2 else dp[n//2-1] * 2)) // 2
