import sys

input = sys.stdin.readline
INF = 10 ** 9


# 2449 전구
# k가지 다른색을 표현할 수 있는 전구 n개의 초기색상이 주어지고
# 전구 하나의 색을 임의의 색으로 바꾸면 인접한 같은색상의 전구도 모두 같은 색으로 바뀐다고 할 때
# n개의 전구의 색을 하나로 통일하기 위해 필요한 색상 변경의 최소 횟수를 구하는 문제
def sol2449():
    input()

    # 전구의 초기 색상 리스트
    # 색상이 같은 인접한 전구 여러개는 하나의 전구와 같으므로
    # 하나의 전구만을 리스트에 삽입
    f, *lb = map(int, input().split())
    seq = [f]
    for b in lb:
        if b != seq[-1]:
            seq.append(b)

    # 인접 중복색상 전구를 제거한 뒤 전구의 갯수
    n = len(seq)

    # dp[i][j] 는 i번 전구부터 j번 전구까지의 색상을 통일하기 위한
    # 최소 색상변경 횟수
    dp = [[0] * n for _ in range(n)]

    # 길이가 2인 구간의 색을 통일
    # 색의 최소 변경 횟수는 1회
    for i in range(n-1):
        dp[i][i+1] = 1

    # 구간의 길이
    for g in range(3, n+1):
        # 구간의 양 끝 인덱스 i, j에 대해
        for i in range(n-g+1):
            j = i + g - 1
            res = INF

            # 양 끝의 전구 색상이 같다면 양 끝을 제외한 가운데 구간을 통일하는데
            # 필요한 최소 색상변경 횟수에 양 끝과 가운데 구간의 색을 맞추기 위한 추가변경 1회를
            # 더한 값이 최솟값이 될 수 있다.
            if seq[i] == seq[j]:
                res = min(res, dp[i+1][j-1] + 1)
            # 양 끝의 전구 색상이 다르다면
            else:
                # 중간점 m을 잡아 구간 i~m 의 최소 색상변경 횟수와
                # m+1~j 의 색상변경 최소횟수를 더한다
                # 구간의 색상은 양 끝의 전구의 색중 하나로 통일할 수 있기 때문에
                # 두 구간의 양쪽 끝 전구 색상중 서로 같은 부분이 있다면
                # 더이상의 색상변경은 필요없다.
                # 같은 부분이 없다면 어느 한쪽 구간의 통일된 색상에 다른쪽 구간의 색을
                # 맞춰야 하기 때문에 1회의 색상변경이 추가로 필요하다.
                for m in range(i, j):
                    res = min(res, dp[i][m] + dp[m+1][j] + (0 if (seq[i] == seq[m+1] or seq[m] == seq[j]) else 1))

            # 구간의 색상 통일을 위환 최소 색상변경 횟수를 저장
            dp[i][j] = res

    # 처음부터 마지막 전구까지의 구간을 통일하기위한 최소 색상변경 횟수 반환
    return dp[0][n-1]
